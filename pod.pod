#!/usr/bin/env perl

=encoding UTF-8

=pod

=encoding UTF-8

=for Info: POD generated by pandoc-plain2pod.pl and pandoc.

=for markdowntext

=head1 USAGE

This is a quick and dirty L<<< I<< pandoc >>|http://pandoc.org >>>
filter which allows you to highlight code in LaTeX output with
L<<< I<< minted >>|https://www.ctan.org/pkg/minted >>> 2.0 rather than
with Pandoc's builtin highlighting mechanism. This is useful because you
get more sophisticated highlighting and formatting of code, and you can
highlight different pieces of code differently, e.g. based on code
language.

First of all read the I<< minted >> documentation, and make sure that
you have I<< minted >> 2.0 or higher and its prerequisites installed.

The filter expects that you use I<< minted >>'s shortcut mechanism to
define highlighting for the various code languages. Thus if you for
example have Bash and Perl code in your document you should create a
file called e.g. C<< mint.ltx >> with the following contents:

    \usepackage{minted}
    \setminted{linenos,breakbytoken}
    \setminted[bash]{bgcolor=LightCyan}
    \setminted[perl]{style=perldoc,bgcolor=Cornsilk}
    \newminted{bash}{}
    \newmintinline{bash}{}
    \newminted{perl}{}
    \newmintinline{perl}{}

B<< Note: >> As you know if you read the I<< minted >> docs the last
argument to C<< \newminted >> and C<< \newmintinline >> should really
contain formatting/style options. However we have already set those with
C<< \setminted >> and use C<< \newminted >> and C<< \newmintinline >>
only to get custom environment/command names, which makes the code which
the filter must inject into the LaTeX output I<< much >> simpler!

In your markdown file you tell the filter which of your defined
I<< minted >> shortcuts you want to use for a particular piece of code
by providing the custom attribute C<< mint=<value> >> with the name of
your shortcut environment/command, I<< minus >> the backslash and the
C<< code >> or C<< inline >> ending as value. Thus since the name of a
I<< minted >> shortcut usually is of the form
C<< \begin{<language>code} >> and C<< \<language>inline >> you usually
give the language name as value:

    ```{.bash .numberLines mint=bash}
    for i in $( ls ); do
        echo item: $i
    done
    ```

    And some inline code `echo item: $i`{.bash mint=bash} too.

(Here C<< .bash >> and C<< .numberLines >> are classes which tell the
builtin Pandoc highlighter how to highlight the code, in case you use it
for other formats than LaTeX, while C<< mint=bash >> tells the filter to
use the C<< \begin{bashcode} >> environment and C<< \bashinline >>
command respectively.

Now if you run I<< pandoc >> like this

    $ pandoc -F pandoc-mintedcode.pl -w latex --no-highlight -H mint.ltx doc.md -o doc.ltx

the Markdown above will have become

    \begin{bashcode}
    for i in $( ls ); do
        echo item: $i
    done
    \end{bashcode}

    And some inline code \bashinline|echo item: $i| too.

There is one thing here which probably need explanation: the
C<< --no-highlight >> in the command line is to disable I<< pandoc's
builtin highlighter >> (supposing that you want to do that!)

Now you can process C<< doc.ltx >> like this:

    $ xelatex -shell-escape doc.ltx

Note that because I<< minted >> needs I<<<<< I<<< latex_ to be run with
the C<< -shell-escape >> option you can't use  >>>pandocI<<<< 's
direct-to-pdf mechanism; you  >>>>have to* first generate a standalone
LaTeX document and run  >>>>>*latex_ normally on that!

=head2 Default environment/command

If your Markdown document contains code only in one language, or mainly
in one language, you can tell the filter to use that language by default
by putting the following metadata block in your Markdown file:

    ---
    mint_block:  perl
    mint_inline: perl
    ...

Having done this (of course substituting your default language for
C<< perl >>!) you don't need to use the C<< mint=<language> >> attribute
on code in your main language; it will be inferred automatically. You
will still need to use C<< \newminted{perl}{...} >> and
C<< \newmintinline{perl}{...} >> in your LaTeX preamble however! Now any
code block or inline code I<< without >> an explicit
C<< mint=<language> >> attribute will become
C<< \begin{perlcode}...\end{perlcode} >> and C<< \perlinline|...| >>
respectively!

=head2 Custom command/environment names and 'suffixes'

The I<< minted >> shortcut commands allow you to specify a custom name
for a shortcut through an optional argument, so that if you for example
want to mark out erroneous perl code specially you can put this in your
LaTeX preamble after C<< \usepackage{minted} >>:

    \newminted[badperlcode]{perl}{bgcolor=Gainsboro}
    \newmintinline[badperlinline]{perl}{bgcolor=Gainsboro}

Then you can use this in your Markdown:

    ```{.perl mint=badperl}
    no strict;
    no warnings;
    ```

    Some more bad Perl: `open FH, '>file.txt';`{mint=badperl} -- old-fashioned!

This illustrates how the 'suffixes' for C<< \minted >> and
C<< \mintinline >> shortcuts, viz. C<< code >> in
C<< \begin{<language>code} >> and C<< \<language>inline >> are
I<< always >> 'inferred by the filter, even when the C<< <value> >> in
the C<< mint=<value> >> attribute isn't really the name of a code
language, (or not I<< only >> the name of a language). However these
suffixes aren't hardcoded. You can use the metadata keys
C<< mint_bsfx >> (for code blocks) and C<< mint_isfx >> (for inline
code) to set them to other values, e.g.

    ---
    mint_bsfx: pre
    mint_isfx: 0
    ...

but then you have to name all your I<< minted >> shortcuts accordingly:

    \newminted[bashpre]{bash}{}
    \newmintinline[bash]{bash}{}

Note here that setting the suffix to C<< 0 >> (zero) or C<< false >>
disables automatic suffixing; you then have to type your
environment/command names in their entirety in your markdown.

=head2 Don't repeat yourself!

Provided the first class, if any, of your code blocks/inlines always is
the language name -- for the benefit of Pandoc's builtin highlighter --
you can set the metadata value C<< mint_pickup >> to a true (to Perl!)
value, and then you don't need to use the C<< mint=<language> >>
attribute at all, provided Pygments's and Pandoc's notion of the
language name coincide. Note that an explicit C<< mint=<language> >>
overrides a class, and an explicit class overrides the value of
C<< mint_block: language >> and C<< mint_inline: language >> in the
metadata. Then you can write

    `echo item: $i`{.bash}

and still use I<< minted >> in LaTeX output!

=head2 Getting rid of C<< mint=<language> >> in HTML output

When producing HTML you don't want C<< mint=<language> >>, which is
invalid HTML, around in your codes' attribute lists. Therefore that
attribute will be stripped if you use this filter with other output
formats than _*latex_ and the metadata key C<< mint_strip >> set to a
true value:

    $ pandoc -w html -F pandoc-mintedcode.pl -M mint_strip doc.md -o doc.html

=head1 WARNINGS

=over

=item *

Since I<< minted >>'s C<< \mintinline >> and shortcuts for it are based
of I<< fancyvrb >>'s C<< \Verb >> they need some (ASCII) punctuation
character as delimiter for the code text. To find a suitable delimiter
the filter greps through the list

    | ~ ` _ ^ @ ? ; : / . , + * ' & % $ # " ! - 

picking the first which doesn't occur in the code. On rare occasions
with some languages (Bash and Perl, I'm looking at you! :-) no such
character may be found, resulting in the error message

    Found no verbatim delimiter for: `` <code> `` at pandoc-mintedcode.pl line 248, <> line 1.
    pandoc: Error running filter pandoc-mintedcode.pl

The workaround is to rephrase so that the piece of code becomes a code
block.

=item *

Because I<< minted >> needs I<<<<< I<<< latex_ to be run with the
C<< -shell-escape >> option you can't use  >>>pandocI<<<< 's
direct-to-pdf mechanism; you  >>>>have to* first generate a standalone
LaTeX document and run  >>>>>*latex_ normally on that!

=back

=for nomarkdowntext

=cut

=cut

# SETUP                                         # {{{1}}}

# use 5.014;
use strict;
use warnings FATAL => 'all';
no warnings qw[ uninitialized numeric ];

use utf8;  # No UTF-8 I/O with JSON!

# use autodie 2.12;

# no indirect;
# no autovivification; # Don't pullute the AST!

# use Getopt::Long qw[ GetOptionsFromArray :config no_ignore_case ];

use JSON::MaybeXS;
use Data::Rmap qw[ rmap_hash cut ]; # Data structure traversal support.
use List::AllUtils 0.09 qw[ firstval ];

sub get_meta_opts;

my $JSON = JSON::MaybeXS->new( utf8 => 1 );

# HELPER FUNCTIONS                              # {{{1}}}
sub _is_elem {                                   # {{{2}}}
    my ( $elem, @tags ) = @_;
    return !!0 unless 'HASH' eq ref $elem;
    return !!0 unless exists $elem->{t};
    return !!0 unless exists $elem->{c};
    if ( @tags ) {
        for my $tag ( @tags ) {
            return !!1 if $tag eq $elem->{t};
        }
        return !!0;
    }
    return !!1;
} ## end sub is_elem

sub _mk_elem {	# {{{2}}}
    my($type => $contents) = @_;
    return +{ t => $type, c => $contents };
}

my @delims = do {
    no warnings 'qw'; # Because comma is in the list!
    qw[ | ~ ` _ ^ @ ? ; : / . , + * ' & % $ # " ! - ];
};

# GET DOCUMENT                                  # {{{1}}}

my $to_format = shift @ARGV;

my $doc = $JSON->decode( do { local $/; <>; } );

# Gather options from the document metadata:    # {{{1}}}

my $option = get_meta_opts(
    +{  doc     => $doc,        #
        opts    => [qw[ block inline bsfx isfx pickup strip ]],    #
        default => +{ bsfx => 'code', isfx => 'inline' },         #
        prefix  => q{mint_},         #
    }
);

my %handler = (
    Code => +{
        "" => sub {
            my($elem) = @_;
            return unless $option->{strip};
            my $attrs = $elem->{c}[-2][2];
            @$attrs = grep { 'mint' ne $_->[0] } @$attrs;
            return;
        },
        latex => sub {
            my($elem) = @_;
            my $attrs = $elem->{c}[-2][2];
            my($mint) = firstval { 'mint' eq $_->[0] } @$attrs;
            $mint &&= $mint->[1];
            $mint ||= ($option->{pickup} ? $elem->{c}[-2][1][0] : undef) 
                || $option->{inline} || return;
            $mint .= $option->{isfx} if $option->{isfx};
            my $code = $elem->{c}[-1];
            my $delim = firstval { $code !~ /\Q$_/ } @delims
                or die "Found no verbatim delimiter for: `` $code ``";
            $code = "\\$mint$delim$code$delim";
            return _mk_elem( RawInline => [ latex => $code ] );
        },
    },
    CodeBlock => +{
        latex => sub {
            my($elem) = @_;
            my $attrs = $elem->{c}[-2][2];
            my($mint) = grep { 'mint' eq $_->[0] } @$attrs;
            $mint &&= $mint->[1];
            $mint ||= ($option->{pickup} ? $elem->{c}[-2][1][0] : undef) 
                || $option->{block} || return;
            $mint .= $option->{bsfx} if $option->{bsfx};
            my $code = $elem->{c}[-1];
            $code = "\\begin\{$mint\}\n$code\n\\end\{$mint\}";
            return _mk_elem( RawBlock => [ latex => $code ] );
        },
    },
);
$handler{CodeBlock}{""} = $handler{Code}{""};

# TRAVERSE DOCUMENT:                            # {{{1}}}

# Change elements in-place:                     # {{{2}}}

rmap_hash {
    return unless _is_elem( $_ );
    my $handler = $handler{$_->{t}}{$to_format} || $handler{$_->{t}}{""};
    return unless $handler;
    my $ret = $handler->($_, @_);
    return unless defined $ret;
    $_ = $ret;
    return;
} $doc;


# Change lists of elements in-place             # {{{2}}}

# traverse_element_lists {
#     return $_ unless _is_elem( ... => $_ );
#     ...
# } $doc;


print {*STDOUT} $JSON->encode( $doc );

# GETTING OPTIONS:                              # {{{1}}}

sub get_meta_opts {                             # {{{2}}}
	my $p = shift;
	my $doc = $p->{doc};
	my $meta = $doc->[0]{unMeta};
	my %opt = %{ $p->{default} || +{} };
	my @opts = @{ $p->{opts} || [] };
	my $pfx = $p->{prefix} || q{};
	@opts = keys %opt unless @opts;
	OPT:
	for my $opt ( @opts ) {
		my $key = $pfx . $opt;
		next unless exists $meta->{$key};
		$opt{$opt} = _get_opt_val( $meta->{$key} );
	}
	return \%opt;
}

# Turn one pandoc metadata value into an option value # {{{2}}}
sub _get_opt_val {
	my($data) = @_;
	if ( 'MetaMap' eq $data->{t} ) {
		return _get_opt_map( $data->{c} );
	}
	elsif ( 'MetaList' eq $data->{t} ) {
		return _get_opt_list( $data->{c} );
	}
	else {
        # Should we return a concatenation instead of 
        # just the first string-ish contents value?
		my($opt) = rmap_hash {
			if ( $_->{t} =~ /\A(?:Str|Meta(?:String|Bool))\z/ ) {
				cut $_->{c};
			}
			elsif ( $_->{t} =~ /\ACode(?:Block)?\z/ ) {
				cut $_->{c}[-1];
			}
			return;
		} $data;
		return $opt;
	}
	return;
}

# Turn a pandoc metadata map into a plain hashref # {{{2}}}
sub _get_opt_map {
	my($href) = @_;
	my %ret;
	while ( my( $k, $v ) = each %$href ) {
		$ret{$k} = _get_opt_val($v);
	}
	return \%ret;
}

# Turn a pandoc metadata list into a plain arrayref # {{{2}}}
sub _get_opt_list {
	my( $aref ) = @_;
	my @ret = map { _get_opt_val($_) } @$aref;
	return \@ret;
}

# # GETTING AND SETTING ATTRIBUTES       # {{{1}}}
#
# sub _get_attrs_hash_for {	# {{{4}}}
#     my($elem) = @_;
#     my $attr_a = $elem->{c}[-2];
#     my($id, $classes, $key_vals) = @$attr_a;
#     tie my %attr => 'Tie::IxHash', map { @$_ } @$key_vals;
#     @attr{ qw[ __id__ __class__ ] } = ( $id, $classes );
#     if ( 'Header' eq $elem->{t} ) {
#         $attr{__header_level__} = $elem->{c}[-3];
#     }
#     return \%attr;
# }

__END__
